---
layout: post
title: 자료구조 기본 정리
categories: [base]
---

**== 자료구조에 대한 기본 ==**<br>

[자료구조]

※기본적으로 자료구조를 사용하는 이유는 시간복잡도와 공간복잡도 관점에서 효율적이기 때문입니다.

​     

⦁시간복잡도는 알고리즘의 연산 횟수를 측정해 시간을 정량화하는 것입니다.

현실에서의 어떠한 문제를 컴퓨터로 해결하기 위해선 적절한 알고리즘을 통해 프로그래밍을 해야 하는데,

for(int I=0; i<n; I++)을 두 번 수행하는 프로그램과 한 번 수행하는 프로그램은 그 속도가 n배나 차이가 납니다.

이러한 속도차이는 연산횟수가 작은 프로그램의 경우 상관이 없겠지만, 대다수 프로그램들이 큰 연산을 처리하기 위해 만들어 지기 때문에 프로그램의 시간적 효율성은 상당히 중요합니다. 시간복잡도는 이를 계산하기 위해 사용됩니다.

​     

⦁공간복잡도는 메모리를 얼마나 사용하는지 계산하여 정량화하는 것입니다.

예를 들어, 크기가 n인 배열을 입력했는데 알고리즘이 내부에서 n x n의 이차원 배열을 생성한다면 이 알고리즘의 공간 복잡도는   ![img]({{ BASE_PATH }}images/base/n2.gif)  이 됩니다. 공간 복잡도는 보통 시간 복잡도에 밀려 중요하게 생각하지 않는 경우가 많으나, 빅데이터 처리를 할 경우 공간 복잡도가 위와 같이 제곱으로 뛰게 되면 프로그램이 메모리에 한 번에 올라가지 않아 프로그램을 실행할 수 없는 문제가 발생합니다. 그래서 보통 빅데이터 처리시 데이터를 나눠서 처리하고 다시 합치는 방법을 사용하게 됩니다.

​     

※어떤 문제를 해결하고자 할 때, 문제의 특성에 따라 큐 or 스택으로 활용하여 문제를 해결하는데 사용합니다.

​     

◉ 선형 구조: 선형 구조란 자료를 구성하고 있는 데이터들이 순차적으로 나열시킨 형태로 자료를 저장하고 꺼내는 것에 초점이 맞춰져 있습니다.

​     

⦁스택 : LIFO (=FILO), 후입선출(선입후출) 형태의 데이터 구조입니다.

스택의 특징으로는, 한 방향 끝에서만 데이터의 삽입과 제거가 이루어진다는 것입니다.

(DFS, 웹 브라우저 방문기록(뒤로가기), 실행취소(undo) 등에 사용)

​     

⦁큐: FIFO, 선입선출 형태의 데이터 구조입니다.

큐는 활용성이 뛰어나 대표적으로 세 가지 구조가 있으며, 선형 큐, 원형 큐, 우선순위 큐가 그 예입니다.

선형 큐는 일반적인 큐를 의미하고, 원형 큐는 큐의 front가 rear과 연결되어 순환되는 구조를 갖는 큐의 형태입니다.

우선순위 큐는 데이터를 우선순위대로 정렬하여 삽입시켜 관리하는 형태의 큐입니다.

(BFS, CPU 스케줄링에 사용, 우선순위가 같은 작업 예약 (인쇄 대기열), 선입선출이 필요한 대기열 (티켓 카운터) ,콜센터 고객 대기시간 등에 사용)

​     

※탐색방법

⦁이진탐색: 정렬된 데이터에서 찾으려는 값과 리스트의 가운데와 비교하여 찾는 방법입니다.

한번 비교해서 찾는 데이터가 아니더라도　정렬되어 있기 때문에 찾는 값이 가운데 값보다 크면

오른쪽 반, 작으면 왼 쪽 반을 비교해 나가며 탐색합니다. 시간복잡도는   ![img]({{ BASE_PATH }}images/base/Ologn.gif)  입니다.

​     

⦁DFS: 스택을 이용하고, 트리 혹은 그래프 같은 자료구조에서 데이터를 탐색할 때 사용하는 알고리즘입니다.

더 이상 길이 없을 때 까지 접근한 후 만약 나아갈 길이 존재하지 않으면 이전의 위치로 돌아와 다른 길을 선택하여 움직이며 탐색하는 방법입니다.

∘장점:

단지 현 경로상의 노드들만을 기억하면 되므로 저장공간의 수요가 비교적 적다. 

목표노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있다.

∘단점:

해가 없는 경로에 깊이 빠질 가능성이 있다. 따라서 실제의 경우 미리 지정한 임의의 깊이까지만 탐색하고 목표노드를 발견하지 못하면 다음의 경로를 따라 탐색하는 방법이 유용할 수 있다. 

얻어진 해가 최단 경로가 된다는 보장이 없다. 이는 목표에 이르는 경로가 다수인 문제에 대해 깊이우선 탐색은 해에 다다르면 탐색을 끝내버리므로, 이때 얻어진 해는 최적이 아닐 수 있다는 의미이다.

​     

⦁BFS: 각 정점을 방문할 때마다 모든 인접 정점들을 검사합니다. 이 중 처음 보는 정점을 발견하면 이 정점들을 큐에 저장합니다. 인접한 정점을 모두 검사하고 나면, 지금까지 저장한 목록에서 다음 정점을 꺼내서 방문하게 됩니다. 따라서 너비 우선 탐색의 방문 순서는 정점의 목록에서 어떤 정점을 먼저 꺼내는지에 의해 결정됩니다.

∘장점: 무한히 깊거나 무한에 가까운 트리인 경우에 효과적이다.

∘단점: 목표 노드로 가는 경로들 모두가 같은 거리일 때 비효율적이다.

​     

※정렬방법

⦁Quick Sort(퀵 정렬): 분할 정복을 이용하여 정렬을 수행하는 알고리즘입니다. pivot point라고 기준이 되는 값을 하나 설정 하는데, 이 값을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮기는 방식으로 정렬을 진행합니다. 시간복잡도는 경우에 따라   ![img]({{ BASE_PATH }}images/base/Onlogn.gif)   ~   ![img]({{ BASE_PATH }}images/base/On2.gif)  으로 나타납니다.

​     

⦁Merge Sort(합병 정렬): 전체 원소를 하나의 단위로 분할한 후 분할한 원소를 다시 병합하는 정렬 방식입니다.

시간복잡도는   ![img]({{ BASE_PATH }}images/base/Onlogn.gif)  입니다.

​     

⦁Counting Sort(카운팅 정렬): 각 배열의 원소 값을 카운트 배열의 인덱스로 두고 각 숫자의 개수를 셉니다.

이 후 정렬된 배열의 인덱스를 담을 배열에 카운트 배열의 값을 카운트 배열의 누적하여 값을 입력해줍니다.

이제 원본 배열의 값을 누적배열의 인덱스의 값자리로 이동 후 값을 감소시켜주며 진행하면 정렬이 됩니다.

시간복잡도는   ![img]({{ BASE_PATH }}images/base/On.gif)  입니다.

​     

⦁Radix Sort(기수 정렬): 1의자리, 10의자리 순으로 정렬해가는 방법입니다.

시간복잡도는   ![img]({{ BASE_PATH }}images/base/Odn.gif)  입니다. (d는 자리수)

{% if site.dispus-shortname %}{% include dispus.html %}{% endif %}