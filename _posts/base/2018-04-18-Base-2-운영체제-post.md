---
layout: post
title: 운영체제 기본 정리
categories: [base]
---

**== 운영체제에 대한 기본 ==**<br>

[운영체제]

⦁임계구역(Critical Section): 여러 개의 프로세스가 같이 접근할 수 있는 구역으로 

공용적으로 사용하는 변수(전역변수등)를 변경 할 수 있는 코드를 담은 구역을 의미합니다. 

하지만 프로세스들이 동시에 같은 임계구역을 처리한다면, 

교착상태(Dead Lock)나 기아현상이 발생할 수 있으므로 

한 프로세스가 임계구역내의 코드를 실행중일 때, 

다른 프로세스들이 임계구역 내의 코드를 실행시킬 수 없게 합니다. 

이러한 처리과정에 대한 문제를 임계구역 문제라 부르고 

이를 해결하기 위해 세마포어(Semaphore), 

상호배제(Mutual Exclusion) (entry영역에서 해주는 것으로, 

하나의 Process만 임계영역에 들어가게 해주는 것), 

진행(Progress) (exit영역에서 임계구역이 빈 상태가 될 경우 Process가 진입할 수 있게 해주는 것),

한정된 대기(Bounded Waiting) 

(일정한 시간을 기다린 후에는 임계구역에 진입하게 해주는 것)등을 이용하여 해결합니다.

​     

⦁세마포(Semaphore): 

수 많은 프로세스를 임계구역(critical section)에 접근하게 할 때, 

wait(약어 P)와 signal(약어 V)의 함수를 적절히 호출하여 

여러 프로세스를 임계구역 내에서 수행하고 sleeping하게 하는 것을 조절하는 변수입니다. 

한정된 수의 사용자만을 지원할 수 있는 공유 자원에 대한 접근을 통제하는데 사용되며, 

프로세스 간 데이터를 동기화하고 보호하려는 목적을 지니고 있습니다.

​     

⦁교착상태(Dead Lock): 

상호배제(Mutual Exclusion) (자원은 한 번에 한 프로세스만이 사용하는 것), 

점유 대기(Hold and Wait) (최소한 하나의 자원을 점유하고 있으면서 

다른 프로세스에 이미 할당된 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다는 것), 

비 선점(No preemption) 

(다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다는 것), 

순환대기 (Circular Wait)

 (프로세스 집합   ![img]({{ BASE_PATH }}images/base/p1.gif)  ~  ![img]({{ BASE_PATH }}images/base/pn.gif)  이 있을 때,   ![img]({{ BASE_PATH }}images/base/p1.gif)  은  ![img]({{ BASE_PATH }}images/base/p2.gif)  가 점유한 자원을 대기하고

   ![img]({{ BASE_PATH }}images/base/p2.gif)    ![img]({{ BASE_PATH }}images/base/pn-1.gif)  이 순서대로 점유한 자원을 대기하는 상태)

가 동시에 성립할 때 발생하는 문제로 여러프로세스가 한정된 자원을 사용하려할 때 발생한다. 

이를 해결하기 위해서는 네 가지 중 한 가지만 성립되지 않게 해주면 된다. 

​     

⦁기아현상(Starvation): 프로세스가 필요한 자원들을 영원히 할당받지 못해서 계속 기다리고 있는 상태

​     

⦁CPU 스케줄링: 메모리에 대기상태의 프로세스 중 하나를 선택해 CPU자원을 할당하는 것



∘최적화 기준: 

CPU 이용률 최대화, 처리량 최대화, 총 처리 시간 최소화, 대기 시간 최소화, 응답 시간 최소화



∘선점(Preemptive) 스케줄링: 

한 프로세스가 CPU를 차지하고 있을 때, 

다른 프로세스가 현재의 프로세스를 중지시키고 자원을 선점하게 하는 방법



∘비선점(Non-Preemptive) 스케줄링: 

일단 CPU가 한 Process에 할당되면, 해당 Process가 종료하던가, 

대기상태로 전환할 때까지 CPU를 점유하는 방법

​     

-SJF(Shortest Job First) 스케줄링: 

처리 시간이 짧은 프로세스부터 자원을 할당받는다. 선점형과 비선점형으로 나뉜다. 

선점형은 새로운 프로세스가 대기큐에 들어왔을 때, 

현재 실행중인 프로세스보다 처리시간이 짧다면 새로운 프로세스부터 우선처리되는 방식이다. 

비선점형은 현재 프로세스가 종료된 후에 우선순위를 판단하여 수행한다.

-장점: 최소의 Average Waiting Time을 실현할 수 있다.

-단점: Starvation이 생길 수 있다.

해결법: Aging (대기 큐에 있는 프로세스에 나이를 부여하여 너무 오래 기다렸을 경우 자원을 할당해준다.)

현실적인 문제점: 처리 시간은 실제로 프로세스를 돌려봐야 정확히 알 수 있다. (따라서 이론적인 방법)

​     

-선입 선출 스케줄링(FCFS – First Come First Served): 들어온 순서대로 처리하는 방법 

-장점: 구현이 가장 간단하고 처리 순서가 명확하다.

-단점: 하나의 큰 프로세스가 오랫동안 자원을 독점하는 동안 작은 프로세스들이 할당을 받지 못하므로 성능이 떨어  질 수 있다.

​     

-HRN(Highest Response-ratio Next) 스케줄링:  SJF의 보완 기법으로 우선순위 공식을 이용해서 

실행 시간이 짧은 프로세스나 대기시간이 긴 프로세스에게 우선순위를 주는 방법

-우선순위 계산식 = (대기시간 + 실행시간) / 실행시간



-우선순위(Priority Scheduling) 스케줄링: 우선순위에 따라서 자원 할당을 해주는 방법으로 

SJF와 마찬가지로 기아 상태가 발생할 수 있다. 역시 Aging을 사용하여 해결 가능하다.

​     

-라운드 로빈 스케줄링(Round-Robin Scheduling): 

시간 할당량(Time Slice)이라는 작은 단위 시간을 주어 이 시간만큼 

모든 프로세스에게 돌아가며 자원을 할당하는 방법이다. 

만약, Time Slice가 너무 크면 FCFS와 다를바가 없고, 

너무 작은 경우에는 오버헤드가 높아 성능이 떨어진다.

​     

-다단계 큐 스케줄링(MultiLevel Queue Scheduling): 

여러개의 큐가 각각 자신만의 스케줄링 알고리즘을 수행한다. 

Foreground 큐(대화형 RR)와 Background 큐(일괄처리 FCFS)로 나누어지며, 

Foreground 큐가 절대적으로 높은 우선순위를 부여 받는다.

Foreground 큐가 80%, Background가 20%할당 하는 식으로 자원을 할당하여 수행하는 방법



{% if site.dispus-shortname %}{% include dispus.html %}{% endif %}